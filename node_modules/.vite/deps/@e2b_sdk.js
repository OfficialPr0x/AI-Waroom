import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/platform/platform.js
var require_platform = __commonJS({
  "node_modules/platform/platform.js"(exports, module) {
    (function() {
      "use strict";
      var objectTypes = {
        "function": true,
        "object": true
      };
      var root = objectTypes[typeof window] && window || this;
      var oldRoot = root;
      var freeExports = objectTypes[typeof exports] && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof globalThis == "object" && globalThis;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
      }
      var maxSafeInteger = Math.pow(2, 53) - 1;
      var reOpera = /\bOpera/;
      var thisBinding = this;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var toString = objectProto.toString;
      function capitalize(string) {
        string = String(string);
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
      function cleanupOS(os, pattern, label) {
        var data = {
          "10.0": "10",
          "6.4": "10 Technical Preview",
          "6.3": "8.1",
          "6.2": "8",
          "6.1": "Server 2008 R2 / 7",
          "6.0": "Server 2008 / Vista",
          "5.2": "Server 2003 / XP 64-bit",
          "5.1": "XP",
          "5.01": "2000 SP1",
          "5.0": "2000",
          "4.0": "NT",
          "4.90": "ME"
        };
        if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) && (data = data[/[\d.]+$/.exec(os)])) {
          os = "Windows " + data;
        }
        os = String(os);
        if (pattern && label) {
          os = os.replace(RegExp(pattern, "i"), label);
        }
        os = format(
          os.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
        );
        return os;
      }
      function each(object, callback) {
        var index = -1, length = object ? object.length : 0;
        if (typeof length == "number" && length > -1 && length <= maxSafeInteger) {
          while (++index < length) {
            callback(object[index], index, object);
          }
        } else {
          forOwn(object, callback);
        }
      }
      function format(string) {
        string = trim(string);
        return /^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string);
      }
      function forOwn(object, callback) {
        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            callback(object[key], key, object);
          }
        }
      }
      function getClassOf(value) {
        return value == null ? capitalize(value) : toString.call(value).slice(8, -1);
      }
      function isHostType(object, property) {
        var type = object != null ? typeof object[property] : "number";
        return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == "object" ? !!object[property] : true);
      }
      function qualify(string) {
        return String(string).replace(/([ -])(?!$)/g, "$1?");
      }
      function reduce(array, callback) {
        var accumulator = null;
        each(array, function(value, index) {
          accumulator = callback(accumulator, value, index, array);
        });
        return accumulator;
      }
      function trim(string) {
        return String(string).replace(/^ +| +$/g, "");
      }
      function parse(ua) {
        var context = root;
        var isCustomContext = ua && typeof ua == "object" && getClassOf(ua) != "String";
        if (isCustomContext) {
          context = ua;
          ua = null;
        }
        var nav = context.navigator || {};
        var userAgent = nav.userAgent || "";
        ua || (ua = userAgent);
        var isModuleScope = isCustomContext || thisBinding == oldRoot;
        var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());
        var objectClass = "Object", airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject", enviroClass = isCustomContext ? objectClass : "Environment", javaClass = isCustomContext && context.java ? "JavaPackage" : getClassOf(context.java), phantomClass = isCustomContext ? objectClass : "RuntimeObject";
        var java = /\bJava/.test(javaClass) && context.java;
        var rhino = java && getClassOf(context.environment) == enviroClass;
        var alpha = java ? "a" : "α";
        var beta = java ? "b" : "β";
        var doc = context.document || {};
        var opera = context.operamini || context.opera;
        var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera)) ? operaClass : opera = null;
        var data;
        var arch = ua;
        var description = [];
        var prerelease = null;
        var useFeatures = ua == userAgent;
        var version2 = useFeatures && opera && typeof opera.version == "function" && opera.version();
        var isSpecialCasedOS;
        var layout = getLayout([
          { "label": "EdgeHTML", "pattern": "Edge" },
          "Trident",
          { "label": "WebKit", "pattern": "AppleWebKit" },
          "iCab",
          "Presto",
          "NetFront",
          "Tasman",
          "KHTML",
          "Gecko"
        ]);
        var name = getName([
          "Adobe AIR",
          "Arora",
          "Avant Browser",
          "Breach",
          "Camino",
          "Electron",
          "Epiphany",
          "Fennec",
          "Flock",
          "Galeon",
          "GreenBrowser",
          "iCab",
          "Iceweasel",
          "K-Meleon",
          "Konqueror",
          "Lunascape",
          "Maxthon",
          { "label": "Microsoft Edge", "pattern": "(?:Edge|Edg|EdgA|EdgiOS)" },
          "Midori",
          "Nook Browser",
          "PaleMoon",
          "PhantomJS",
          "Raven",
          "Rekonq",
          "RockMelt",
          { "label": "Samsung Internet", "pattern": "SamsungBrowser" },
          "SeaMonkey",
          { "label": "Silk", "pattern": "(?:Cloud9|Silk-Accelerated)" },
          "Sleipnir",
          "SlimBrowser",
          { "label": "SRWare Iron", "pattern": "Iron" },
          "Sunrise",
          "Swiftfox",
          "Vivaldi",
          "Waterfox",
          "WebPositive",
          { "label": "Yandex Browser", "pattern": "YaBrowser" },
          { "label": "UC Browser", "pattern": "UCBrowser" },
          "Opera Mini",
          { "label": "Opera Mini", "pattern": "OPiOS" },
          "Opera",
          { "label": "Opera", "pattern": "OPR" },
          "Chromium",
          "Chrome",
          { "label": "Chrome", "pattern": "(?:HeadlessChrome)" },
          { "label": "Chrome Mobile", "pattern": "(?:CriOS|CrMo)" },
          { "label": "Firefox", "pattern": "(?:Firefox|Minefield)" },
          { "label": "Firefox for iOS", "pattern": "FxiOS" },
          { "label": "IE", "pattern": "IEMobile" },
          { "label": "IE", "pattern": "MSIE" },
          "Safari"
        ]);
        var product = getProduct([
          { "label": "BlackBerry", "pattern": "BB10" },
          "BlackBerry",
          { "label": "Galaxy S", "pattern": "GT-I9000" },
          { "label": "Galaxy S2", "pattern": "GT-I9100" },
          { "label": "Galaxy S3", "pattern": "GT-I9300" },
          { "label": "Galaxy S4", "pattern": "GT-I9500" },
          { "label": "Galaxy S5", "pattern": "SM-G900" },
          { "label": "Galaxy S6", "pattern": "SM-G920" },
          { "label": "Galaxy S6 Edge", "pattern": "SM-G925" },
          { "label": "Galaxy S7", "pattern": "SM-G930" },
          { "label": "Galaxy S7 Edge", "pattern": "SM-G935" },
          "Google TV",
          "Lumia",
          "iPad",
          "iPod",
          "iPhone",
          "Kindle",
          { "label": "Kindle Fire", "pattern": "(?:Cloud9|Silk-Accelerated)" },
          "Nexus",
          "Nook",
          "PlayBook",
          "PlayStation Vita",
          "PlayStation",
          "TouchPad",
          "Transformer",
          { "label": "Wii U", "pattern": "WiiU" },
          "Wii",
          "Xbox One",
          { "label": "Xbox 360", "pattern": "Xbox" },
          "Xoom"
        ]);
        var manufacturer = getManufacturer({
          "Apple": { "iPad": 1, "iPhone": 1, "iPod": 1 },
          "Alcatel": {},
          "Archos": {},
          "Amazon": { "Kindle": 1, "Kindle Fire": 1 },
          "Asus": { "Transformer": 1 },
          "Barnes & Noble": { "Nook": 1 },
          "BlackBerry": { "PlayBook": 1 },
          "Google": { "Google TV": 1, "Nexus": 1 },
          "HP": { "TouchPad": 1 },
          "HTC": {},
          "Huawei": {},
          "Lenovo": {},
          "LG": {},
          "Microsoft": { "Xbox": 1, "Xbox One": 1 },
          "Motorola": { "Xoom": 1 },
          "Nintendo": { "Wii U": 1, "Wii": 1 },
          "Nokia": { "Lumia": 1 },
          "Oppo": {},
          "Samsung": { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
          "Sony": { "PlayStation": 1, "PlayStation Vita": 1 },
          "Xiaomi": { "Mi": 1, "Redmi": 1 }
        });
        var os = getOS([
          "Windows Phone",
          "KaiOS",
          "Android",
          "CentOS",
          { "label": "Chrome OS", "pattern": "CrOS" },
          "Debian",
          { "label": "DragonFly BSD", "pattern": "DragonFly" },
          "Fedora",
          "FreeBSD",
          "Gentoo",
          "Haiku",
          "Kubuntu",
          "Linux Mint",
          "OpenBSD",
          "Red Hat",
          "SuSE",
          "Ubuntu",
          "Xubuntu",
          "Cygwin",
          "Symbian OS",
          "hpwOS",
          "webOS ",
          "webOS",
          "Tablet OS",
          "Tizen",
          "Linux",
          "Mac OS X",
          "Macintosh",
          "Mac",
          "Windows 98;",
          "Windows "
        ]);
        function getLayout(guesses) {
          return reduce(guesses, function(result, guess) {
            return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
          });
        }
        function getManufacturer(guesses) {
          return reduce(guesses, function(result, value, key) {
            return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua)) && key;
          });
        }
        function getName(guesses) {
          return reduce(guesses, function(result, guess) {
            return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
          });
        }
        function getOS(guesses) {
          return reduce(guesses, function(result, guess) {
            var pattern = guess.pattern || qualify(guess);
            if (!result && (result = RegExp("\\b" + pattern + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua))) {
              result = cleanupOS(result, pattern, guess.label || guess);
            }
            return result;
          });
        }
        function getProduct(guesses) {
          return reduce(guesses, function(result, guess) {
            var pattern = guess.pattern || qualify(guess);
            if (!result && (result = RegExp("\\b" + pattern + " *\\d+[.\\w_]*", "i").exec(ua) || RegExp("\\b" + pattern + " *\\w+-[\\w]*", "i").exec(ua) || RegExp("\\b" + pattern + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua))) {
              if ((result = String(guess.label && !RegExp(pattern, "i").test(guess.label) ? guess.label : result).split("/"))[1] && !/[\d.]+/.test(result[0])) {
                result[0] += " " + result[1];
              }
              guess = guess.label || guess;
              result = format(result[0].replace(RegExp(pattern, "i"), guess).replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ").replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2"));
            }
            return result;
          });
        }
        function getVersion(patterns) {
          return reduce(patterns, function(result, pattern) {
            return result || (RegExp(pattern + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua) || 0)[1] || null;
          });
        }
        function toStringPlatform() {
          return this.description || "";
        }
        layout && (layout = [layout]);
        if (/\bAndroid\b/.test(os) && !product && (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))) {
          product = trim(data[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null;
        }
        if (manufacturer && !product) {
          product = getProduct([manufacturer]);
        } else if (manufacturer && product) {
          product = product.replace(RegExp("^(" + qualify(manufacturer) + ")[-_.\\s]", "i"), manufacturer + " ").replace(RegExp("^(" + qualify(manufacturer) + ")[-_.]?(\\w)", "i"), manufacturer + " $2");
        }
        if (data = /\bGoogle TV\b/.exec(product)) {
          product = data[0];
        }
        if (/\bSimulator\b/i.test(ua)) {
          product = (product ? product + " " : "") + "Simulator";
        }
        if (name == "Opera Mini" && /\bOPiOS\b/.test(ua)) {
          description.push("running in Turbo/Uncompressed mode");
        }
        if (name == "IE" && /\blike iPhone OS\b/.test(ua)) {
          data = parse(ua.replace(/like iPhone OS/, ""));
          manufacturer = data.manufacturer;
          product = data.product;
        } else if (/^iP/.test(product)) {
          name || (name = "Safari");
          os = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua)) ? " " + data[1].replace(/_/g, ".") : "");
        } else if (name == "Konqueror" && /^Linux\b/i.test(os)) {
          os = "Kubuntu";
        } else if (manufacturer && manufacturer != "Google" && (/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua)) {
          name = "Android Browser";
          os = /\bAndroid\b/.test(os) ? os : "Android";
        } else if (name == "Silk") {
          if (!/\bMobi/i.test(ua)) {
            os = "Android";
            description.unshift("desktop mode");
          }
          if (/Accelerated *= *true/i.test(ua)) {
            description.unshift("accelerated");
          }
        } else if (name == "UC Browser" && /\bUCWEB\b/.test(ua)) {
          description.push("speed mode");
        } else if (name == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
          description.push("identifying as Firefox " + data[1]);
        } else if (name == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
          os || (os = "Firefox OS");
          product || (product = data[1]);
        } else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
          if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + "/") + 8))) {
            name = null;
          }
          if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
            name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + " Browser";
          }
        } else if (name == "Electron" && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
          description.push("Chromium " + data);
        }
        if (!version2) {
          version2 = getVersion([
            "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
            "Version",
            qualify(name),
            "(?:Firefox|Minefield|NetFront)"
          ]);
        }
        if (data = layout == "iCab" && parseFloat(version2) > 3 && "WebKit" || /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit" || !layout && /\bMSIE\b/i.test(ua) && (os == "Mac OS" ? "Tasman" : "Trident") || layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name) && "NetFront") {
          layout = [data];
        }
        if (name == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
          name += " Mobile";
          os = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
          description.unshift("desktop mode");
        } else if (/\bWPDesktop\b/i.test(ua)) {
          name = "IE Mobile";
          os = "Windows Phone 8.x";
          description.unshift("desktop mode");
          version2 || (version2 = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
        } else if (name != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua))) {
          if (name) {
            description.push("identifying as " + name + (version2 ? " " + version2 : ""));
          }
          name = "IE";
          version2 = data[1];
        }
        if (useFeatures) {
          if (isHostType(context, "global")) {
            if (java) {
              data = java.lang.System;
              arch = data.getProperty("os.arch");
              os = os || data.getProperty("os.name") + " " + data.getProperty("os.version");
            }
            if (rhino) {
              try {
                version2 = context.require("ringo/engine").version.join(".");
                name = "RingoJS";
              } catch (e) {
                if ((data = context.system) && data.global.system == context.system) {
                  name = "Narwhal";
                  os || (os = data[0].os || null);
                }
              }
              if (!name) {
                name = "Rhino";
              }
            } else if (typeof context.process == "object" && !context.process.browser && (data = context.process)) {
              if (typeof data.versions == "object") {
                if (typeof data.versions.electron == "string") {
                  description.push("Node " + data.versions.node);
                  name = "Electron";
                  version2 = data.versions.electron;
                } else if (typeof data.versions.nw == "string") {
                  description.push("Chromium " + version2, "Node " + data.versions.node);
                  name = "NW.js";
                  version2 = data.versions.nw;
                }
              }
              if (!name) {
                name = "Node.js";
                arch = data.arch;
                os = data.platform;
                version2 = /[\d.]+/.exec(data.version);
                version2 = version2 ? version2[0] : null;
              }
            }
          } else if (getClassOf(data = context.runtime) == airRuntimeClass) {
            name = "Adobe AIR";
            os = data.flash.system.Capabilities.os;
          } else if (getClassOf(data = context.phantom) == phantomClass) {
            name = "PhantomJS";
            version2 = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
          } else if (typeof doc.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua))) {
            version2 = [version2, doc.documentMode];
            if ((data = +data[1] + 4) != version2[1]) {
              description.push("IE " + version2[1] + " mode");
              layout && (layout[1] = "");
              version2[1] = data;
            }
            version2 = name == "IE" ? String(version2[1].toFixed(1)) : version2[0];
          } else if (typeof doc.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(name)) {
            description.push("masking as " + name + " " + version2);
            name = "IE";
            version2 = "11.0";
            layout = ["Trident"];
            os = "Windows";
          }
          os = os && format(os);
        }
        if (version2 && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version2) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ";" + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && "a")) {
          prerelease = /b/i.test(data) ? "beta" : "alpha";
          version2 = version2.replace(RegExp(data + "\\+?$"), "") + (prerelease == "beta" ? beta : alpha) + (/\d+\+?/.exec(data) || "");
        }
        if (name == "Fennec" || name == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os)) {
          name = "Firefox Mobile";
        } else if (name == "Maxthon" && version2) {
          version2 = version2.replace(/\.[\d.]+/, ".x");
        } else if (/\bXbox\b/i.test(product)) {
          if (product == "Xbox 360") {
            os = null;
          }
          if (product == "Xbox 360" && /\bIEMobile\b/.test(ua)) {
            description.unshift("mobile mode");
          }
        } else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os == "Windows CE" || /Mobi/i.test(ua))) {
          name += " Mobile";
        } else if (name == "IE" && useFeatures) {
          try {
            if (context.external === null) {
              description.unshift("platform preview");
            }
          } catch (e) {
            description.unshift("embedded");
          }
        } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua) || 0)[1] || version2)) {
          data = [data, /BB10/.test(ua)];
          os = (data[1] ? (product = null, manufacturer = "BlackBerry") : "Device Software") + " " + data[0];
          version2 = null;
        } else if (this != forOwn && product != "Wii" && (useFeatures && opera || /Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os) || name == "IE" && (os && !/^Win/.test(os) && version2 > 5.5 || /\bWindows XP\b/.test(os) && version2 > 8 || version2 == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse.call(forOwn, ua.replace(reOpera, "") + ";")) && data.name) {
          data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
          if (reOpera.test(name)) {
            if (/\bIE\b/.test(data) && os == "Mac OS") {
              os = null;
            }
            data = "identify" + data;
          } else {
            data = "mask" + data;
            if (operaClass) {
              name = format(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
            } else {
              name = "Opera";
            }
            if (/\bIE\b/.test(data)) {
              os = null;
            }
            if (!useFeatures) {
              version2 = null;
            }
          }
          layout = ["Presto"];
          description.push(data);
        }
        if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
          data = [parseFloat(data.replace(/\.(\d)$/, ".0$1")), data];
          if (name == "Safari" && data[1].slice(-1) == "+") {
            name = "WebKit Nightly";
            prerelease = "alpha";
            version2 = data[1].slice(0, -1);
          } else if (version2 == data[1] || version2 == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
            version2 = null;
          }
          data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
          if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
            layout = ["Blink"];
          }
          if (!useFeatures || !likeChrome && !data[1]) {
            layout && (layout[1] = "like Safari");
            data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? "4+" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : "12");
          } else {
            layout && (layout[1] = "like Chrome");
            data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? "13+" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? "21+" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != "Blink" ? "27" : "28");
          }
          layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
          if (name == "Safari" && (!version2 || parseInt(version2) > 45)) {
            version2 = data;
          } else if (name == "Chrome" && /\bHeadlessChrome/i.test(ua)) {
            description.unshift("headless");
          }
        }
        if (name == "Opera" && (data = /\bzbov|zvav$/.exec(os))) {
          name += " ";
          description.unshift("desktop mode");
          if (data == "zvav") {
            name += "Mini";
            version2 = null;
          } else {
            name += "Mobile";
          }
          os = os.replace(RegExp(" *" + data + "$"), "");
        } else if (name == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
          description.unshift("desktop mode");
          name = "Chrome Mobile";
          version2 = null;
          if (/\bOS X\b/.test(os)) {
            manufacturer = "Apple";
            os = "iOS 4.3+";
          } else {
            os = null;
          }
        } else if (/\bSRWare Iron\b/.test(name) && !version2) {
          version2 = getVersion("Chrome");
        }
        if (version2 && version2.indexOf(data = /[\d.]+$/.exec(os)) == 0 && ua.indexOf("/" + data + "-") > -1) {
          os = trim(os.replace(data, ""));
        }
        if (os && os.indexOf(name) != -1 && !RegExp(name + " OS").test(os)) {
          os = os.replace(RegExp(" *" + qualify(name) + " *"), "");
        }
        if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || name != "Safari" && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name) && layout[1])) {
          (data = layout[layout.length - 1]) && description.push(data);
        }
        if (description.length) {
          description = ["(" + description.join("; ") + ")"];
        }
        if (manufacturer && product && product.indexOf(manufacturer) < 0) {
          description.push("on " + manufacturer);
        }
        if (product) {
          description.push((/^on /.test(description[description.length - 1]) ? "" : "on ") + product);
        }
        if (os) {
          data = / ([\d.+]+)$/.exec(os);
          isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == "/";
          os = {
            "architecture": 32,
            "family": data && !isSpecialCasedOS ? os.replace(data[0], "") : os,
            "version": data ? data[1] : null,
            "toString": function() {
              var version3 = this.version;
              return this.family + (version3 && !isSpecialCasedOS ? " " + version3 : "") + (this.architecture == 64 ? " 64-bit" : "");
            }
          };
        }
        if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
          if (os) {
            os.architecture = 64;
            os.family = os.family.replace(RegExp(" *" + data), "");
          }
          if (name && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
            description.unshift("32-bit");
          }
        } else if (os && /^OS X/.test(os.family) && name == "Chrome" && parseFloat(version2) >= 39) {
          os.architecture = 64;
        }
        ua || (ua = null);
        var platform3 = {};
        platform3.description = ua;
        platform3.layout = layout && layout[0];
        platform3.manufacturer = manufacturer;
        platform3.name = name;
        platform3.prerelease = prerelease;
        platform3.product = product;
        platform3.ua = ua;
        platform3.version = name && version2;
        platform3.os = os || {
          /**
           * The CPU architecture the OS is built for.
           *
           * @memberOf platform.os
           * @type number|null
           */
          "architecture": null,
          /**
           * The family of the OS.
           *
           * Common values include:
           * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
           * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
           * "SuSE", "Android", "iOS" and "Windows Phone"
           *
           * @memberOf platform.os
           * @type string|null
           */
          "family": null,
          /**
           * The version of the OS.
           *
           * @memberOf platform.os
           * @type string|null
           */
          "version": null,
          /**
           * Returns the OS string.
           *
           * @memberOf platform.os
           * @returns {string} The OS string.
           */
          "toString": function() {
            return "null";
          }
        };
        platform3.parse = parse;
        platform3.toString = toStringPlatform;
        if (platform3.version) {
          description.unshift(version2);
        }
        if (platform3.name) {
          description.unshift(name);
        }
        if (os && name && !(os == String(os).split(" ")[0] && (os == name.split(" ")[0] || product))) {
          description.push(product ? "(" + os + ")" : "on " + os);
        }
        if (description.length) {
          platform3.description = description.join(" ");
        }
        return platform3;
      }
      var platform2 = parse();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root.platform = platform2;
        define(function() {
          return platform2;
        });
      } else if (freeExports && freeModule) {
        forOwn(platform2, function(value, key) {
          freeExports[key] = value;
        });
      } else {
        root.platform = platform2;
      }
    }).call(exports);
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/normalize-path/index.js"(exports, module) {
    module.exports = function(path2, stripTrailing) {
      if (typeof path2 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path2 === "\\" || path2 === "/") return "/";
      var len = path2.length;
      if (len <= 1) return path2;
      var prefix = "";
      if (len > 4 && path2[3] === "\\") {
        var ch = path2[2];
        if ((ch === "?" || ch === ".") && path2.slice(0, 2) === "\\\\") {
          path2 = path2.slice(2);
          prefix = "//";
        }
      }
      var segs = path2.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// node_modules/rpc-websocket-client/node_modules/uuid/lib/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/rpc-websocket-client/node_modules/uuid/lib/rng-browser.js"(exports, module) {
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      rnds8 = new Uint8Array(16);
      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      rnds = new Array(16);
      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0) r = Math.random() * 4294967296;
          rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds8;
    var rnds;
  }
});

// node_modules/rpc-websocket-client/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/rpc-websocket-client/node_modules/uuid/lib/bytesToUuid.js"(exports, module) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module.exports = bytesToUuid;
  }
});

// node_modules/rpc-websocket-client/node_modules/uuid/v1.js
var require_v1 = __commonJS({
  "node_modules/rpc-websocket-client/node_modules/uuid/v1.js"(exports, module) {
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v12(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module.exports = v12;
  }
});

// node_modules/isomorphic-ws/browser.js
var require_browser = __commonJS({
  "node_modules/isomorphic-ws/browser.js"(exports, module) {
    var ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof globalThis !== "undefined") {
      ws = globalThis.WebSocket || globalThis.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    module.exports = ws;
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path2.length; ++i) {
        if (i < path2.length)
          code = path2.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path2.slice(lastSlash + 1, i);
            else
              res = path2.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path2;
          if (i >= 0)
            path2 = arguments[i];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path2 = cwd;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var isAbsolute = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute);
        if (path2.length === 0 && !isAbsolute) path2 = ".";
        if (path2.length > 0 && trailingSeparator) path2 += "/";
        if (isAbsolute) return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path2) {
        return path2;
      },
      dirname: function dirname(path2) {
        assertPath(path2);
        if (path2.length === 0) return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path2.length - 1; i >= 1; --i) {
          code = path2.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path2.slice(0, end);
      },
      basename: function basename(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path2.length - 1; i >= 0; --i) {
            var code = path2.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i = path2.length - 1; i >= 0; --i) {
            if (path2.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path2.length - 1; i >= 0; --i) {
          var code = path2.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path2) {
        assertPath(path2);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path2.length === 0) return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path2.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path2.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);
            else ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module.exports = posix;
  }
});

// node_modules/openapi-typescript-fetch/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  ApiError: () => ApiError,
  Fetcher: () => Fetcher,
  arrayRequestBody: () => arrayRequestBody
});

// node_modules/openapi-typescript-fetch/dist/esm/types.js
var never = Symbol();
var ApiError = class extends Error {
  constructor(response) {
    super(response.statusText);
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "statusText", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.setPrototypeOf(this, new.target.prototype);
    this.headers = response.headers;
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.data = response.data;
  }
};

// node_modules/openapi-typescript-fetch/dist/esm/fetcher.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var sendBody = (method) => method === "post" || method === "put" || method === "patch" || method === "delete";
function queryString(params) {
  const qs = [];
  const encode = (key, value) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;
  Object.keys(params).forEach((key) => {
    const value = params[key];
    if (value != null) {
      if (Array.isArray(value)) {
        value.forEach((value2) => qs.push(encode(key, value2)));
      } else {
        qs.push(encode(key, value));
      }
    }
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
}
function getPath(path2, payload) {
  return path2.replace(/\{([^}]+)\}/g, (_, key) => {
    const value = encodeURIComponent(payload[key]);
    delete payload[key];
    return value;
  });
}
function getQuery(method, payload, query) {
  let queryObj = {};
  if (sendBody(method)) {
    query.forEach((key) => {
      queryObj[key] = payload[key];
      delete payload[key];
    });
  } else {
    queryObj = Object.assign({}, payload);
  }
  return queryString(queryObj);
}
function getHeaders(body, init) {
  const headers = new Headers(init);
  if (body !== void 0 && !headers.has("Content-Type")) {
    headers.append("Content-Type", "application/json");
  }
  if (!headers.has("Accept")) {
    headers.append("Accept", "application/json");
  }
  return headers;
}
function getBody(method, payload) {
  const body = sendBody(method) ? JSON.stringify(payload) : void 0;
  return method === "delete" && body === "{}" ? void 0 : body;
}
function mergeRequestInit(first, second) {
  const headers = new Headers(first === null || first === void 0 ? void 0 : first.headers);
  const other = new Headers(second === null || second === void 0 ? void 0 : second.headers);
  for (const key of other.keys()) {
    const value = other.get(key);
    if (value != null) {
      headers.set(key, value);
    }
  }
  return Object.assign(Object.assign(Object.assign({}, first), second), { headers });
}
function getFetchParams(request) {
  var _a3;
  const payload = Object.assign(Array.isArray(request.payload) ? [] : {}, request.payload);
  const path2 = getPath(request.path, payload);
  const query = getQuery(request.method, payload, request.queryParams);
  const body = getBody(request.method, payload);
  const headers = getHeaders(body, (_a3 = request.init) === null || _a3 === void 0 ? void 0 : _a3.headers);
  const url = request.baseUrl + path2 + query;
  const init = Object.assign(Object.assign({}, request.init), {
    method: request.method.toUpperCase(),
    headers,
    body
  });
  return { url, init };
}
function getResponseData(response) {
  return __awaiter(this, void 0, void 0, function* () {
    const contentType = response.headers.get("content-type");
    if (response.status === 204) {
      return void 0;
    }
    if (contentType && contentType.indexOf("application/json") !== -1) {
      return yield response.json();
    }
    const text = yield response.text();
    try {
      return JSON.parse(text);
    } catch (e) {
      return text;
    }
  });
}
function fetchJson(url, init) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield fetch(url, init);
    const data = yield getResponseData(response);
    const result = {
      headers: response.headers,
      url: response.url,
      ok: response.ok,
      status: response.status,
      statusText: response.statusText,
      data
    };
    if (result.ok) {
      return result;
    }
    throw new ApiError(result);
  });
}
function wrapMiddlewares(middlewares, fetch2) {
  const handler = (index, url, init) => __awaiter(this, void 0, void 0, function* () {
    if (middlewares == null || index === middlewares.length) {
      return fetch2(url, init);
    }
    const current = middlewares[index];
    return yield current(url, init, (nextUrl, nextInit) => handler(index + 1, nextUrl, nextInit));
  });
  return (url, init) => handler(0, url, init);
}
function fetchUrl(request) {
  return __awaiter(this, void 0, void 0, function* () {
    const { url, init } = getFetchParams(request);
    const response = yield request.fetch(url, init);
    return response;
  });
}
function createFetch(fetch2) {
  const fun = (payload, init) => __awaiter(this, void 0, void 0, function* () {
    try {
      return yield fetch2(payload, init);
    } catch (err) {
      if (err instanceof ApiError) {
        throw new fun.Error(err);
      }
      throw err;
    }
  });
  fun.Error = class extends ApiError {
    constructor(error) {
      super(error);
      Object.setPrototypeOf(this, new.target.prototype);
    }
    getActualType() {
      return {
        status: this.status,
        data: this.data
      };
    }
  };
  return fun;
}
function fetcher() {
  let baseUrl = "";
  let defaultInit = {};
  const middlewares = [];
  const fetch2 = wrapMiddlewares(middlewares, fetchJson);
  return {
    configure: (config) => {
      baseUrl = config.baseUrl || "";
      defaultInit = config.init || {};
      middlewares.splice(0);
      middlewares.push(...config.use || []);
    },
    use: (mw) => middlewares.push(mw),
    path: (path2) => ({
      method: (method) => ({
        create: (queryParams) => createFetch((payload, init) => fetchUrl({
          baseUrl: baseUrl || "",
          path: path2,
          method,
          queryParams: Object.keys(queryParams || {}),
          payload,
          init: mergeRequestInit(defaultInit, init),
          fetch: fetch2
        }))
      })
    })
  };
}
var Fetcher = {
  for: () => fetcher()
};

// node_modules/openapi-typescript-fetch/dist/esm/utils.js
function arrayRequestBody(array, params) {
  return Object.assign([...array], params);
}

// node_modules/@e2b/sdk/dist/index.mjs
var import_platform = __toESM(require_platform(), 1);
var import_normalize_path = __toESM(require_normalize_path(), 1);

// node_modules/rpc-websocket-client/dist/rpc-websocket-client.es5.js
var v1 = require_v1();
var WebSocket2 = require_browser();
var RpcVersions;
(function(RpcVersions2) {
  RpcVersions2["RPC_VERSION"] = "2.0";
})(RpcVersions || (RpcVersions = {}));
var RpcWebSocketClient = (
  /** @class */
  function() {
    function RpcWebSocketClient2() {
      this.idAwaiter = {};
      this.onOpenHandlers = [];
      this.onAnyMessageHandlers = [];
      this.onNotification = [];
      this.onRequest = [];
      this.onSuccessResponse = [];
      this.onErrorResponse = [];
      this.onErrorHandlers = [];
      this.onCloseHandlers = [];
      this.config = {
        responseTimeout: 1e4
      };
      this.ws = void 0;
    }
    RpcWebSocketClient2.prototype.connect = function(url, protocols) {
      this.ws = new WebSocket2(url, protocols);
      return this.listen();
    };
    RpcWebSocketClient2.prototype.onOpen = function(fn) {
      this.onOpenHandlers.push(fn);
    };
    RpcWebSocketClient2.prototype.onAnyMessage = function(fn) {
      this.onAnyMessageHandlers.push(fn);
    };
    RpcWebSocketClient2.prototype.onError = function(fn) {
      this.onErrorHandlers.push(fn);
    };
    RpcWebSocketClient2.prototype.onClose = function(fn) {
      this.onCloseHandlers.push(fn);
    };
    RpcWebSocketClient2.prototype.listenMessages = function() {
      var _this = this;
      var previousOnMessage;
      if (this.ws.onmessage) {
        previousOnMessage = this.ws.onmessage.bind(this.ws);
      }
      this.ws.onmessage = function(e) {
        if (previousOnMessage) {
          previousOnMessage(e);
        }
        for (var _i = 0, _a3 = _this.onAnyMessageHandlers; _i < _a3.length; _i++) {
          var handler = _a3[_i];
          handler(e);
        }
        var data = JSON.parse(e.data.toString());
        if (_this.isNotification(data)) {
          for (var _b = 0, _c = _this.onNotification; _b < _c.length; _b++) {
            var handler = _c[_b];
            handler(data);
          }
        } else if (_this.isRequest(data)) {
          for (var _d = 0, _e = _this.onRequest; _d < _e.length; _d++) {
            var handler = _e[_d];
            handler(data);
          }
        } else if (_this.isSuccessResponse(data)) {
          for (var _f = 0, _g = _this.onSuccessResponse; _f < _g.length; _f++) {
            var handler = _g[_f];
            handler(data);
          }
          _this.idAwaiter[data.id](data.result);
        } else if (_this.isErrorResponse(data)) {
          for (var _h = 0, _j = _this.onErrorResponse; _h < _j.length; _h++) {
            var handler = _j[_h];
            handler(data);
          }
          _this.idAwaiter[data.id](data.error);
        }
      };
    };
    RpcWebSocketClient2.prototype.call = function(method, params) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var data = _this.buildRequest(method, params);
        var timeout;
        if (_this.config.responseTimeout) {
          timeout = setTimeout(function() {
            delete _this.idAwaiter[data.id];
            reject('Awaiting response to "' + method + '" with id: ' + data.id + " timed out.");
          }, _this.config.responseTimeout);
        }
        _this.idAwaiter[data.id] = function(responseData) {
          clearInterval(timeout);
          delete _this.idAwaiter[data.id];
          if (_this.isRpcError(responseData)) {
            reject(responseData);
            return;
          }
          resolve(responseData);
        };
        var json = JSON.stringify(data);
        _this.ws.send(json);
      });
    };
    RpcWebSocketClient2.prototype.notify = function(method, params) {
      this.ws.send(JSON.stringify(this.buildNotification(method, params)));
    };
    RpcWebSocketClient2.prototype.customId = function(idFn) {
      this.idFn = idFn;
    };
    RpcWebSocketClient2.prototype.noRpc = function() {
      this.buildRequest = this.buildRequestBase;
      this.buildNotification = this.buildNotificationBase;
      this.buildRpcSuccessResponse = this.buildRpcSuccessResponseBase;
      this.buildRpcErrorResponse = this.buildRpcErrorResponseBase;
    };
    RpcWebSocketClient2.prototype.configure = function(options) {
      Object.assign(this.config, options);
    };
    RpcWebSocketClient2.prototype.changeSocket = function(ws) {
      this.ws = ws;
    };
    RpcWebSocketClient2.prototype.listen = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        _this.ws.onopen = function(e) {
          for (var _i = 0, _a3 = _this.onOpenHandlers; _i < _a3.length; _i++) {
            var handler = _a3[_i];
            handler(e);
          }
          resolve(e);
        };
        _this.listenMessages();
        _this.ws.onerror = function(e) {
          for (var _i = 0, _a3 = _this.onErrorHandlers; _i < _a3.length; _i++) {
            var handler = _a3[_i];
            handler(e);
          }
        };
        _this.ws.onclose = function(e) {
          for (var _i = 0, _a3 = _this.onCloseHandlers; _i < _a3.length; _i++) {
            var handler = _a3[_i];
            handler(e);
          }
          reject(e);
        };
      });
    };
    RpcWebSocketClient2.prototype.buildRequest = function(method, params) {
      var data = this.buildRequestBase(method, params);
      data.jsonrpc = RpcVersions.RPC_VERSION;
      return data;
    };
    RpcWebSocketClient2.prototype.buildRequestBase = function(method, params) {
      var data = {};
      data.id = this.idFn();
      data.method = method;
      if (params) {
        data.params = params;
      }
      return data;
    };
    RpcWebSocketClient2.prototype.buildNotification = function(method, params) {
      var data = this.buildNotificationBase(method, params);
      data.jsonrpc = RpcVersions.RPC_VERSION;
      return data;
    };
    RpcWebSocketClient2.prototype.buildNotificationBase = function(method, params) {
      var data = {};
      data.method = method;
      if (params) {
        data.params = params;
      }
      return data;
    };
    RpcWebSocketClient2.prototype.buildRpcSuccessResponse = function(id2, result) {
      var data = this.buildRpcSuccessResponseBase(id2, result);
      data.jsonrpc = RpcVersions.RPC_VERSION;
      return data;
    };
    RpcWebSocketClient2.prototype.buildRpcSuccessResponseBase = function(id2, result) {
      var data = {};
      data.id = id2;
      data.result = result;
      return data;
    };
    RpcWebSocketClient2.prototype.buildRpcErrorResponse = function(id2, error) {
      var data = this.buildRpcErrorResponseBase(id2, error);
      data.jsonrpc = RpcVersions.RPC_VERSION;
      return data;
    };
    RpcWebSocketClient2.prototype.buildRpcErrorResponseBase = function(id2, error) {
      var data = {};
      data.id = id2;
      data.error = error;
      return data;
    };
    RpcWebSocketClient2.prototype.idFn = function() {
      return v1();
    };
    RpcWebSocketClient2.prototype.isNotification = function(data) {
      return !data.id;
    };
    RpcWebSocketClient2.prototype.isRequest = function(data) {
      return data.method;
    };
    RpcWebSocketClient2.prototype.isSuccessResponse = function(data) {
      return data.hasOwnProperty("result");
    };
    RpcWebSocketClient2.prototype.isErrorResponse = function(data) {
      return data.hasOwnProperty("error");
    };
    RpcWebSocketClient2.prototype.isRpcError = function(data) {
      var _a3;
      return typeof ((_a3 = data) === null || _a3 === void 0 ? void 0 : _a3.code) !== "undefined";
    };
    return RpcWebSocketClient2;
  }()
);

// node_modules/@e2b/sdk/dist/index.mjs
var import_path_browserify = __toESM(require_path_browserify(), 1);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var SANDBOX_REFRESH_PERIOD = 5e3;
var WS_RECONNECT_INTERVAL = 600;
var TIMEOUT = 6e4;
var API_DOMAIN = "api.e2b.dev";
var _a;
var API_HOST = ((_a = process == null ? void 0 : process.env) == null ? void 0 : _a.E2B_DEBUG) ? "http://localhost:3000" : `https://${API_DOMAIN}`;
var SANDBOX_DOMAIN = "e2b.dev";
var ENVD_PORT = 49982;
var WS_ROUTE = "/ws";
var FILE_ROUTE = "/file";
var version = "0.11.5";
var _a2;
var defaultHeaders = {
  browser: typeof window !== "undefined" && import_platform.default.name || "undefined",
  lang: "js",
  lang_version: import_platform.default.version || "unknown",
  package_version: version,
  publisher: "e2b",
  sdk_runtime: typeof window === "undefined" ? "node" : "browser",
  system: ((_a2 = import_platform.default.os) == null ? void 0 : _a2.family) || "unknown"
};
var { Fetcher: Fetcher2 } = esm_exports;
var client = Fetcher2.for();
client.configure({
  baseUrl: API_HOST,
  init: {
    headers: defaultHeaders
  }
});
function withAccessToken(f) {
  const wrapped = (accessToken, arg, init) => {
    return f(arg, __spreadProps(__spreadValues({}, init), {
      headers: __spreadValues({
        Authorization: `Bearer ${accessToken}`
      }, init == null ? void 0 : init.headers)
    }));
  };
  wrapped.Error = f.Error;
  return wrapped;
}
function withAPIKey(f) {
  const wrapped = (apiKey, arg, init) => {
    return f(arg, __spreadProps(__spreadValues({}, init), {
      headers: __spreadValues({
        "X-API-KEY": apiKey
      }, init == null ? void 0 : init.headers)
    }));
  };
  wrapped.Error = f.Error;
  return wrapped;
}
var api_default = client;
var terminalService = "terminal";
var TerminalOutput = class {
  constructor() {
    this._data = "";
  }
  get data() {
    return this._data;
  }
  addData(data) {
    this._data += data;
  }
};
var Terminal = class {
  constructor(terminalID, sandbox, triggerExit, finished, output) {
    this.terminalID = terminalID;
    this.sandbox = sandbox;
    this.triggerExit = triggerExit;
    this.output = output;
    this.finished = finished;
  }
  get data() {
    return this.output.data;
  }
  /**
   * Kills the terminal session.
   */
  kill() {
    return __async(this, null, function* () {
      try {
        yield this.sandbox._call(terminalService, "destroy", [this.terminalID]);
      } finally {
        this.triggerExit();
        yield this.finished;
      }
    });
  }
  /**
   * Waits for the terminal to finish.
   */
  wait() {
    return __async(this, null, function* () {
      return this.finished;
    });
  }
  /**
   * Sends data to the terminal standard input.
   *
   * @param data Data to send
   */
  sendData(data) {
    return __async(this, null, function* () {
      yield this.sandbox._call(terminalService, "data", [this.terminalID, data]);
    });
  }
  /**
   * Resizes the terminal tty.
   *
   * @param cols Number of columns
   * @param rows Number of rows
   */
  resize(_0) {
    return __async(this, arguments, function* ({ cols, rows }) {
      yield this.sandbox._call(terminalService, "resize", [
        this.terminalID,
        cols,
        rows
      ]);
    });
  }
};
var TimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var AbortError = class extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message === false) {
        resolve();
      } else if (message instanceof Error) {
        reject(message);
      } else {
        timeoutError.message = message != null ? message : `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (() => __async(this, null, function* () {
      try {
        resolve(yield promise);
      } catch (error) {
        reject(error);
      }
    }))();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}
function assertFulfilled(item) {
  return item.status === "fulfilled";
}
function formatSettledErrors(settled) {
  if (settled.every((s) => s.status === "fulfilled"))
    return;
  return settled.reduce((prev, curr, i) => {
    if (curr.status === "rejected") {
      return prev + `
[${i}]: ${JSON.stringify(curr)}`;
    }
    return prev;
  }, "errors:\n");
}
function createDeferredPromise() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    reject,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    resolve
  };
}
function withTimeout(fn, timeout = TIMEOUT) {
  if (timeout === void 0 || timeout <= 0 || timeout === Number.POSITIVE_INFINITY) {
    return fn;
  }
  return (...args) => pTimeout(fn(...args), { milliseconds: timeout });
}
var filesystemService = "filesystem";
var FilesystemOperation = ((FilesystemOperation2) => {
  FilesystemOperation2["Create"] = "Create";
  FilesystemOperation2["Write"] = "Write";
  FilesystemOperation2["Remove"] = "Remove";
  FilesystemOperation2["Rename"] = "Rename";
  FilesystemOperation2["Chmod"] = "Chmod";
  return FilesystemOperation2;
})(FilesystemOperation || {});
var FilesystemWatcher = class {
  constructor(sessConn, path2) {
    this.sessConn = sessConn;
    this.path = path2;
    this.listeners = /* @__PURE__ */ new Set();
  }
  // Starts watching the path that was passed to the contructor
  start(opts) {
    return __async(this, null, function* () {
      const start = () => __async(this, null, function* () {
        if (this.rpcSubscriptionID)
          return;
        this.handleFilesystemEvents = this.handleFilesystemEvents.bind(this);
        this.rpcSubscriptionID = yield this.sessConn._subscribe(
          filesystemService,
          this.handleFilesystemEvents,
          "watchDir",
          this.path
        );
      });
      return yield withTimeout(start, opts == null ? void 0 : opts.timeout)();
    });
  }
  // Stops watching the path and removes all listeners.
  stop() {
    return __async(this, null, function* () {
      this.listeners.clear();
      if (this.rpcSubscriptionID) {
        yield this.sessConn._unsubscribe(this.rpcSubscriptionID);
      }
    });
  }
  addEventListener(l) {
    this.listeners.add(l);
    return () => this.listeners.delete(l);
  }
  handleFilesystemEvents(fsChange) {
    this.listeners.forEach((l) => {
      l(fsChange);
    });
  }
};
var filesystemWatcher_default = FilesystemWatcher;
var processService = "process";
var ProcessMessage = class {
  constructor(line, timestamp, error) {
    this.line = line;
    this.timestamp = timestamp;
    this.error = error;
  }
  toString() {
    return this.line;
  }
};
var ProcessOutput = class {
  constructor() {
    this.delimiter = "\n";
    this.messages = [];
    this._finished = false;
    this._error = false;
  }
  /**
   * Whether the process has errored.
   */
  get error() {
    return this._error;
  }
  /**
   * The exit code of the process.
   */
  get exitCode() {
    if (!this._finished) {
      throw new Error("Process has not finished yet");
    }
    return this._exitCode;
  }
  /**
   * The stdout from the process.
   */
  get stdout() {
    return this.messages.filter((out) => !out.error).map((out) => out.line).join(this.delimiter);
  }
  /**
   * The stderr from the process.
   */
  get stderr() {
    return this.messages.filter((out) => out.error).map((out) => out.line).join(this.delimiter);
  }
  addStdout(message) {
    this.insertByTimestamp(message);
  }
  addStderr(message) {
    this._error = true;
    this.insertByTimestamp(message);
  }
  setExitCode(exitCode) {
    this._exitCode = exitCode;
    this._finished = true;
  }
  insertByTimestamp(message) {
    let i = this.messages.length - 1;
    while (i >= 0 && this.messages[i].timestamp > message.timestamp) {
      i -= 1;
    }
    this.messages.splice(i + 1, 0, message);
  }
};
var Process = class {
  constructor(processID, sandbox, triggerExit, finished, output) {
    this.processID = processID;
    this.sandbox = sandbox;
    this.triggerExit = triggerExit;
    this.output = output;
    this.finished = finished;
  }
  /**
   * Kills the process.
   */
  kill() {
    return __async(this, null, function* () {
      try {
        yield this.sandbox._call(processService, "kill", [this.processID]);
      } finally {
        this.triggerExit();
        yield this.finished;
      }
    });
  }
  /**
   * Waits for the process to finish.
   */
  wait() {
    return __async(this, null, function* () {
      return this.finished;
    });
  }
  /**
   * Sends data to the process stdin.
   *
   * @param data Data to send
   * @param opts Call options
   * @param {timeout} [opts.timeout] Timeout for call in milliseconds (default is 60 seconds)
   */
  sendStdin(data, opts) {
    return __async(this, null, function* () {
      yield this.sandbox._call(
        processService,
        "stdin",
        [this.processID, data],
        opts
      );
    });
  }
};
function id(length) {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
var codeSnippetService = "codeSnippet";
var AuthenticationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AuthenticationError";
  }
};
var CurrentWorkingDirectoryDoesntExistError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CurrentWorkingDirectoryDoesntExistError";
  }
};
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
var wait_default = wait;
var createSandbox = withAPIKey(
  api_default.path("/instances").method("post").create()
);
var refreshSandbox = withAPIKey(
  api_default.path("/instances/{instanceID}/refreshes").method("post").create()
);
var SandboxConnection = class {
  // let's keep opts readonly, but public - for convenience, mainly when debugging
  constructor(opts) {
    this.opts = opts;
    this.isOpen = false;
    this.rpc = new RpcWebSocketClient();
    this.subscribers = [];
    var _a3, _b, _c, _d;
    this.sandbox = opts.__sandbox;
    const apiKey = opts.apiKey || ((_a3 = process == null ? void 0 : process.env) == null ? void 0 : _a3.E2B_API_KEY);
    if (!apiKey) {
      throw new AuthenticationError(
        "API key is required, please visit https://e2b.dev/docs to get your API key"
      );
    }
    this.apiKey = apiKey;
    this.cwd = opts.cwd;
    if (this.cwd && this.cwd.startsWith("~")) {
      this.cwd = this.cwd.replace("~", "/home/user");
    }
    this.envVars = opts.envVars || {};
    this.logger = (_b = opts.logger) != null ? _b : {
      // by default, we log to the console
      // we don't log debug messages by default
      info: console.info,
      warn: console.warn,
      error: console.error
    };
    (_d = (_c = this.logger).debug) == null ? void 0 : _d.call(_c, `Sandbox "${this.templateID}" initialized`);
  }
  get id() {
    var _a3, _b;
    return `${(_a3 = this.sandbox) == null ? void 0 : _a3.instanceID}-${(_b = this.sandbox) == null ? void 0 : _b.clientID}`;
  }
  get templateID() {
    return this.opts.template || this.opts.id || "base";
  }
  /**
   * Keep the sandbox alive for the specified duration.
   *
   * `keepAlive` method requires `this` context - you may need to bind it.
   * @param duration Duration in milliseconds
   * @returns Promise that resolves when the sandbox is kept alive
   */
  keepAlive(duration) {
    return __async(this, null, function* () {
      var _a3;
      duration = Math.round(duration / 1e3);
      if (duration < 0 || duration > 3600) {
        throw new Error("Duration must be between 0 and 3600 seconds");
      }
      if (!this.sandbox) {
        throw new Error("Cannot keep alive - sandbox is not initialized");
      }
      yield refreshSandbox(this.apiKey, {
        instanceID: (_a3 = this.sandbox) == null ? void 0 : _a3.instanceID,
        duration
      });
    });
  }
  /**
   * Get the hostname for the sandbox or for the specified sandbox's port.
   *
   * `getHostname` method requires `this` context - you may need to bind it.
   *
   * @param port Specify if you want to connect to a specific port of the sandbox
   * @returns Hostname of the sandbox or sandbox's port
   */
  getHostname(port) {
    if (this.opts.__debug_hostname) {
      if (port && this.opts.__debug_devEnv === "remote") {
        return `${port}-${this.opts.__debug_hostname}`;
      } else if (port) {
        return `${this.opts.__debug_hostname}:${port}`;
      } else {
        return this.opts.__debug_hostname;
      }
    }
    if (!this.sandbox) {
      return void 0;
    }
    const hostname = `${this.sandbox.instanceID}-${this.sandbox.clientID}.${SANDBOX_DOMAIN}`;
    if (port) {
      return `${port}-${hostname}`;
    } else {
      return hostname;
    }
  }
  /**
   * Close the connection to the sandbox
   *
   * `close` method requires `this` context - you may need to bind it.
   */
  close() {
    return __async(this, null, function* () {
      var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (this.isOpen) {
        (_c = (_b = this.logger).debug) == null ? void 0 : _c.call(_b, `Closing sandbox "${(_a3 = this.sandbox) == null ? void 0 : _a3.instanceID}"`);
        this.isOpen = false;
        (_e = (_d = this.logger).debug) == null ? void 0 : _e.call(_d, "Unsubscribing...");
        const results = yield Promise.allSettled(
          this.subscribers.map((s) => this._unsubscribe(s.subID))
        );
        results.forEach((r) => {
          var _a4, _b2;
          if (r.status === "rejected") {
            (_b2 = (_a4 = this.logger).warn) == null ? void 0 : _b2.call(_a4, `Failed to unsubscribe: "${r.reason}"`);
          }
        });
        (_g = (_f = this.rpc.ws) == null ? void 0 : _f.terminate) == null ? void 0 : _g.call(_f);
        (_i = (_h = this.rpc.ws) == null ? void 0 : _h.close) == null ? void 0 : _i.call(_h);
        (_k = (_j = this.logger).debug) == null ? void 0 : _k.call(_j, "Disconnected from the sandbox");
      }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _call(service, method, params, opts) {
    return __async(this, null, function* () {
      var _a3, _b;
      (_b = (_a3 = this.logger).debug) == null ? void 0 : _b.call(_a3, `Calling "${service}_${method}" with params:`, params);
      const call = (method2, params2) => __async(this, null, function* () {
        return yield this.rpc.call(method2, params2);
      });
      return yield withTimeout(call, opts == null ? void 0 : opts.timeout)(
        `${service}_${method}`,
        params
      );
    });
  }
  _handleSubscriptions(...subs) {
    return __async(this, null, function* () {
      const results = yield Promise.allSettled(subs);
      if (results.every((r) => r.status === "fulfilled")) {
        return results.map(
          (r) => r.status === "fulfilled" ? r.value : void 0
        );
      }
      yield Promise.all(
        results.filter(assertFulfilled).map((r) => r.value ? this._unsubscribe(r.value) : void 0)
      );
      throw new Error(formatSettledErrors(results));
    });
  }
  // eslint-disable-next-line @typescript-eslint/member-ordering
  _unsubscribe(subID) {
    return __async(this, null, function* () {
      var _a3, _b;
      const subscription = this.subscribers.find((s) => s.subID === subID);
      if (!subscription)
        return;
      yield this._call(subscription.service, "unsubscribe", [subscription.subID]);
      this.subscribers = this.subscribers.filter((s) => s !== subscription);
      (_b = (_a3 = this.logger).debug) == null ? void 0 : _b.call(
        _a3,
        `Unsubscribed '${subID}' from '${subscription.service}'`
      );
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/member-ordering
  _subscribe(service, handler, method, ...params) {
    return __async(this, null, function* () {
      var _a3, _b;
      const subID = yield this._call(service, "subscribe", [method, ...params]);
      if (typeof subID !== "string") {
        throw new Error(
          `Cannot subscribe to ${service}_${method}${params.length > 0 ? " with params [" + params.join(", ") + "]" : ""}. Expected response should have been a subscription ID, instead we got ${JSON.stringify(
            subID
          )}`
        );
      }
      this.subscribers.push({
        handler,
        service,
        subID
      });
      (_b = (_a3 = this.logger).debug) == null ? void 0 : _b.call(
        _a3,
        `Subscribed to "${service}_${method}"${params.length > 0 ? " with params [" + params.join(", ") + "] and" : ""} with id "${subID}"`
      );
      return subID;
    });
  }
  /**
   * Open a connection to a new sandbox
   *
   * `open` method requires `this` context - you may need to bind it.
   * @param opts Call options
   * @param {timeout} [opts.timeout] Timeout for sandbox to open in milliseconds (default is 60 seconds)
   */
  _open(opts) {
    return __async(this, null, function* () {
      const open = () => __async(this, null, function* () {
        var _a3, _b, _c, _d;
        if (this.isOpen) {
          throw new Error("Sandbox connect was already called");
        } else {
          this.isOpen = true;
        }
        (_b = (_a3 = this.logger).debug) == null ? void 0 : _b.call(_a3, "Opening sandbox...");
        if (!this.sandbox) {
          try {
            const res = yield createSandbox(this.apiKey, {
              envID: this.templateID
            });
            this.sandbox = res.data;
            (_d = (_c = this.logger).debug) == null ? void 0 : _d.call(_c, `Acquired sandbox "${this.sandbox.instanceID}"`);
          } catch (e) {
            if (e instanceof createSandbox.Error) {
              const error = e.getActualType();
              if (error.status === 400) {
                throw new Error(
                  `Error creating sandbox - (${error.status}) bad request: ${error.data.message}`
                );
              }
              if (error.status === 401) {
                throw new Error(
                  `Error creating sandbox - (${error.status}) unauthenticated: ${error.data.message}`
                );
              }
              if (error.status === 500) {
                throw new Error(
                  `Error creating sandbox - (${error.status}) server error: ${error.data.message}`
                );
              }
            }
            throw e;
          }
        }
        this.refresh(this.sandbox.instanceID);
        yield this.connectRpc();
        return this;
      });
      return yield withTimeout(open, opts == null ? void 0 : opts.timeout)();
    });
  }
  connectRpc() {
    return __async(this, null, function* () {
      var _a3, _b, _c, _d, _e, _f, _g, _h;
      const hostname = this.getHostname(this.opts.__debug_port || ENVD_PORT);
      if (!hostname) {
        throw new Error("Cannot get sandbox's hostname");
      }
      const protocol = this.opts.__debug_devEnv === "local" ? "ws" : "wss";
      const sandboxURL = `${protocol}://${hostname}${WS_ROUTE}`;
      this.rpc.onError((err) => {
        var _a4, _b2, _c2, _d2, _e2;
        (_e2 = (_d2 = this.logger).debug) == null ? void 0 : _e2.call(
          _d2,
          `Error in WebSocket of sandbox "${(_a4 = this.sandbox) == null ? void 0 : _a4.instanceID}": ${(_c2 = (_b2 = err.message) != null ? _b2 : err.code) != null ? _c2 : err.toString()}. Trying to reconnect...`
        );
      });
      let isFinished = false;
      let resolveOpening;
      let rejectOpening;
      const openingPromise = new Promise((resolve, reject) => {
        resolveOpening = () => {
          if (isFinished)
            return;
          isFinished = true;
          resolve();
        };
        rejectOpening = () => {
          if (isFinished)
            return;
          isFinished = true;
          reject();
        };
      });
      this.rpc.onOpen(() => {
        var _a4, _b2, _c2;
        (_c2 = (_b2 = this.logger).debug) == null ? void 0 : _c2.call(
          _b2,
          `Connected to sandbox "${(_a4 = this.sandbox) == null ? void 0 : _a4.instanceID}"`
        );
        resolveOpening == null ? void 0 : resolveOpening();
      });
      this.rpc.onClose(() => __async(this, null, function* () {
        var _a4, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i, _j, _k, _l, _m, _n;
        (_c2 = (_b2 = this.logger).debug) == null ? void 0 : _c2.call(
          _b2,
          `Closing WebSocket connection to sandbox "${(_a4 = this.sandbox) == null ? void 0 : _a4.instanceID}"`
        );
        if (this.isOpen) {
          yield wait_default(WS_RECONNECT_INTERVAL);
          (_f2 = (_e2 = this.logger).debug) == null ? void 0 : _f2.call(
            _e2,
            `Reconnecting to sandbox "${(_d2 = this.sandbox) == null ? void 0 : _d2.instanceID}"`
          );
          try {
            this.subscribers = [];
            yield this.rpc.connect(sandboxURL);
            (_i = (_h2 = this.logger).debug) == null ? void 0 : _i.call(
              _h2,
              `Reconnected to sandbox "${(_g2 = this.sandbox) == null ? void 0 : _g2.instanceID}"`
            );
          } catch (err) {
            (_n = (_m = this.logger).debug) == null ? void 0 : _n.call(
              _m,
              `Failed reconnecting to sandbox "${(_j = this.sandbox) == null ? void 0 : _j.instanceID}": ${(_l = (_k = err.message) != null ? _k : err.code) != null ? _l : err.toString()}`
            );
          }
        } else {
          rejectOpening == null ? void 0 : rejectOpening();
        }
      }));
      this.rpc.onNotification.push(this.handleNotification.bind(this));
      try {
        (_c = (_b = this.logger).debug) == null ? void 0 : _c.call(
          _b,
          `Connection to sandbox "${(_a3 = this.sandbox) == null ? void 0 : _a3.instanceID}"`
        );
        yield this.rpc.connect(sandboxURL);
      } catch (err) {
        (_h = (_g = this.logger).debug) == null ? void 0 : _h.call(
          _g,
          `Error connecting to sandbox "${(_d = this.sandbox) == null ? void 0 : _d.instanceID}": ${(_f = (_e = err.message) != null ? _e : err.code) != null ? _f : err.toString()}`
        );
      }
      yield openingPromise;
    });
  }
  handleNotification(data) {
    var _a3, _b;
    (_b = (_a3 = this.logger).debug) == null ? void 0 : _b.call(_a3, "Handling notification:", data);
    this.subscribers.filter((s) => {
      var _a4;
      return s.subID === ((_a4 = data.params) == null ? void 0 : _a4.subscription);
    }).forEach((s) => {
      var _a4;
      return s.handler((_a4 = data.params) == null ? void 0 : _a4.result);
    });
  }
  refresh(instanceID) {
    return __async(this, null, function* () {
      var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      (_b = (_a3 = this.logger).debug) == null ? void 0 : _b.call(_a3, `Started refreshing sandbox "${instanceID}"`);
      try {
        while (true) {
          if (!this.isOpen) {
            (_e = (_d = this.logger).debug) == null ? void 0 : _e.call(
              _d,
              `Cannot refresh sandbox ${(_c = this.sandbox) == null ? void 0 : _c.instanceID} - it was closed`
            );
            return;
          }
          yield wait_default(SANDBOX_REFRESH_PERIOD);
          try {
            (_g = (_f = this.logger).debug) == null ? void 0 : _g.call(_f, `Refreshed sandbox "${instanceID}"`);
            yield refreshSandbox(this.apiKey, {
              instanceID,
              duration: 0
            });
          } catch (e) {
            if (e instanceof refreshSandbox.Error) {
              const error = e.getActualType();
              if (error.status === 404) {
                (_i = (_h = this.logger).warn) == null ? void 0 : _i.call(
                  _h,
                  `Error refreshing sandbox - (${error.status}): ${error.data.message}`
                );
                return;
              }
              (_k = (_j = this.logger).warn) == null ? void 0 : _k.call(
                _j,
                `Refreshing sandbox "${instanceID}" failed - (${error.status})`
              );
            }
          }
        }
      } finally {
        (_m = (_l = this.logger).debug) == null ? void 0 : _m.call(_l, `Stopped refreshing sandbox "${instanceID}"`);
        yield this.close();
      }
    });
  }
};
var resolvePath = (inputPath, cwd, logger) => {
  var _a3, _b, _c;
  let result;
  if (inputPath.startsWith("./")) {
    result = import_path_browserify.default.posix.join(cwd || "/home/user", inputPath);
    if (!cwd) {
      (_a3 = logger.warn) == null ? void 0 : _a3.call(
        logger,
        `Path starts with './' and cwd isn't set. The path '${inputPath}' will evaluate to '${result}', which may not be what you want.`
      );
    }
    return result;
  }
  if (inputPath.startsWith("../")) {
    result = import_path_browserify.default.posix.join(cwd || "/home/user", inputPath);
    if (!cwd) {
      (_b = logger.warn) == null ? void 0 : _b.call(
        logger,
        `Path starts with '../' and cwd isn't set. The path '${inputPath}' will evaluate to '${result}', which may not be what you want.`
      );
    }
    return result;
  }
  if (inputPath.startsWith("~/")) {
    result = import_path_browserify.default.posix.join(cwd || "/home/user", inputPath.substring(2));
    if (!cwd) {
      (_c = logger.warn) == null ? void 0 : _c.call(
        logger,
        `Path starts with '~/' and cwd isn't set. The path '${inputPath}' will evaluate to '${result}', which may not be what you want.`
      );
    }
    return result;
  }
  if (!inputPath.startsWith("/") && cwd) {
    return import_path_browserify.default.posix.join(cwd, inputPath);
  }
  return inputPath;
};
var Actions = class {
  constructor(sandbox) {
    this.sandbox = sandbox;
  }
  /**
   * Call the required actions for the provided run and return their outputs.
   * 
   * @param run OpenAI run object from `openai.beta.threads.runs.retrieve` or `openai.beta.threads.runs.retrieve.create` call that contains the names of the required actions and their arguments.
   * @returns The outputs of the required actions in the run.
   */
  run(run) {
    return __async(this, null, function* () {
      if (run.status !== "requires_action") {
        return [];
      }
      if (!run.required_action) {
        return [];
      }
      const outputs = [];
      for (const toolCall of run.required_action.submit_tool_outputs.tool_calls) {
        const action = this.sandbox._actions.get(toolCall.function.name);
        if (!action) {
          console.warn(`Action ${toolCall.function.name} not found`);
          continue;
        }
        const args = JSON.parse(toolCall.function.arguments);
        const output = yield action(this.sandbox, args);
        outputs.push({
          tool_call_id: toolCall.id,
          output
        });
      }
      return outputs;
    });
  }
};
var Sandbox = class extends SandboxConnection {
  constructor(opts) {
    opts = opts || {};
    super(opts);
    this._actions = /* @__PURE__ */ new Map();
    this.onScanPorts = opts.onScanPorts;
    this.filesystem = {
      list: (path2, opts2) => __async(this, null, function* () {
        return yield this._call(
          filesystemService,
          "list",
          [_resolvePath(path2)],
          opts2
        );
      }),
      read: (path2, opts2) => __async(this, null, function* () {
        return yield this._call(
          filesystemService,
          "read",
          [_resolvePath(path2)],
          opts2
        );
      }),
      remove: (path2, opts2) => __async(this, null, function* () {
        yield this._call(
          filesystemService,
          "remove",
          [_resolvePath(path2)],
          opts2
        );
      }),
      write: (path2, content, opts2) => __async(this, null, function* () {
        yield this._call(
          filesystemService,
          "write",
          [_resolvePath(path2), content],
          opts2
        );
      }),
      writeBytes: (path2, content) => __async(this, null, function* () {
        const base64Content = Buffer.from(content).toString("base64");
        yield this._call(filesystemService, "writeBase64", [
          _resolvePath(path2),
          base64Content
        ]);
      }),
      readBytes: (path2) => __async(this, null, function* () {
        const base64Content = yield this._call(
          filesystemService,
          "readBase64",
          [_resolvePath(path2)]
        );
        return Buffer.from(base64Content, "base64");
      }),
      makeDir: (path2, opts2) => __async(this, null, function* () {
        yield this._call(
          filesystemService,
          "makeDir",
          [_resolvePath(path2)],
          opts2
        );
      }),
      watchDir: (path2) => {
        var _a3, _b;
        (_b = (_a3 = this.logger).debug) == null ? void 0 : _b.call(_a3, `Watching directory "${path2}"`);
        const npath = (0, import_normalize_path.default)(_resolvePath(path2));
        return new filesystemWatcher_default(this, npath);
      }
    };
    this.terminal = {
      start: (_0) => __async(this, [_0], function* ({
        onData,
        size,
        onExit,
        envVars,
        cmd,
        cwd = "",
        terminalID = id(12),
        timeout = void 0
      }) {
        const start = (_02) => __async(this, [_02], function* ({
          onData: onData2,
          size: size2,
          onExit: onExit2,
          envVars: envVars2,
          cmd: cmd2,
          cwd: cwd2 = "",
          rootDir,
          terminalID: terminalID2 = id(12)
        }) {
          var _a3, _b, _c, _d;
          (_b = (_a3 = this.logger).debug) == null ? void 0 : _b.call(_a3, `Starting terminal "${terminalID2}"`);
          if (!cwd2 && rootDir) {
            (_d = (_c = this.logger).warn) == null ? void 0 : _d.call(
              _c,
              "The rootDir parameter is deprecated, use cwd instead."
            );
            cwd2 = rootDir;
          }
          if (!cwd2 && this.cwd) {
            cwd2 = this.cwd;
          }
          envVars2 = envVars2 || {};
          envVars2 = __spreadValues(__spreadValues({}, this.envVars), envVars2);
          const { promise: terminalExited, resolve: triggerExit } = createDeferredPromise();
          const output = new TerminalOutput();
          function handleData(data) {
            output.addData(data);
            onData2 == null ? void 0 : onData2(data);
          }
          const [onDataSubID, onExitSubID] = yield this._handleSubscriptions(
            this._subscribe(terminalService, handleData, "onData", terminalID2),
            this._subscribe(terminalService, triggerExit, "onExit", terminalID2)
          );
          const { promise: unsubscribing, resolve: handleFinishUnsubscribing } = createDeferredPromise();
          terminalExited.then(() => __async(this, null, function* () {
            var _a4, _b2, _c2, _d2;
            const results = yield Promise.allSettled([
              this._unsubscribe(onExitSubID),
              this._unsubscribe(onDataSubID)
            ]);
            (_b2 = (_a4 = this.logger).debug) == null ? void 0 : _b2.call(_a4, `Terminal "${terminalID2}" exited`);
            const errMsg = formatSettledErrors(results);
            if (errMsg) {
              (_d2 = (_c2 = this.logger).error) == null ? void 0 : _d2.call(_c2, errMsg);
            }
            onExit2 == null ? void 0 : onExit2();
            handleFinishUnsubscribing(output);
          }));
          try {
            yield this._call(terminalService, "start", [
              terminalID2,
              size2.cols,
              size2.rows,
              // Handle optional args for old devbookd compatibility
              ...cmd2 !== void 0 ? [envVars2, cmd2, cwd2] : []
            ]);
          } catch (err) {
            triggerExit();
            yield unsubscribing;
            throw err;
          }
          return new Terminal(
            terminalID2,
            this,
            triggerExit,
            unsubscribing,
            output
          );
        });
        return yield withTimeout(
          start,
          timeout
        )({
          onData,
          size,
          onExit,
          envVars,
          cmd,
          cwd,
          terminalID
        });
      })
    };
    this.process = {
      start: (optsOrCmd) => __async(this, null, function* () {
        const opts2 = typeof optsOrCmd === "string" ? { cmd: optsOrCmd } : optsOrCmd;
        const start = (_0) => __async(this, [_0], function* ({
          cmd,
          onStdout,
          onStderr,
          onExit,
          envVars = {},
          cwd = "",
          rootDir,
          processID = id(12)
        }) {
          var _a3, _b, _c, _d;
          if (!cwd && rootDir) {
            (_b = (_a3 = this.logger).warn) == null ? void 0 : _b.call(
              _a3,
              "The rootDir parameter is deprecated, use cwd instead."
            );
            cwd = rootDir;
          }
          if (!cwd && this.cwd) {
            cwd = this.cwd;
          }
          if (!cmd)
            throw new Error("cmd is required");
          envVars = envVars || {};
          envVars = __spreadValues(__spreadValues({}, this.envVars), envVars);
          (_d = (_c = this.logger).debug) == null ? void 0 : _d.call(_c, `Starting process "${processID}", cmd: "${cmd}"`);
          const { promise: processExited, resolve: triggerExit } = createDeferredPromise();
          const output = new ProcessOutput();
          const handleExit = (exitCode) => {
            output.setExitCode(exitCode);
            triggerExit();
          };
          const handleStdout = (data) => {
            const message = new ProcessMessage(
              data.line,
              data.timestamp,
              false
            );
            output.addStdout(message);
            if (onStdout) {
              onStdout(message);
            } else if (this.opts.onStdout) {
              this.opts.onStdout(message);
            }
          };
          const handleStderr = (data) => {
            const message = new ProcessMessage(data.line, data.timestamp, true);
            output.addStderr(message);
            if (onStderr) {
              onStderr(message);
            } else if (this.opts.onStderr) {
              this.opts.onStderr(message);
            }
          };
          const [onExitSubID, onStdoutSubID, onStderrSubID] = yield this._handleSubscriptions(
            this._subscribe(processService, handleExit, "onExit", processID),
            this._subscribe(
              processService,
              handleStdout,
              "onStdout",
              processID
            ),
            this._subscribe(
              processService,
              handleStderr,
              "onStderr",
              processID
            )
          );
          const { promise: unsubscribing, resolve: handleFinishUnsubscribing } = createDeferredPromise();
          processExited.then(() => __async(this, null, function* () {
            var _a4, _b2, _c2, _d2;
            const results = yield Promise.allSettled([
              this._unsubscribe(onExitSubID),
              onStdoutSubID ? this._unsubscribe(onStdoutSubID) : void 0,
              onStderrSubID ? this._unsubscribe(onStderrSubID) : void 0
            ]);
            (_b2 = (_a4 = this.logger).debug) == null ? void 0 : _b2.call(_a4, `Process "${processID}" exited`);
            const errMsg = formatSettledErrors(results);
            if (errMsg) {
              (_d2 = (_c2 = this.logger).error) == null ? void 0 : _d2.call(_c2, errMsg);
            }
            if (onExit) {
              onExit(output.exitCode || 0);
            } else if (this.opts.onExit) {
              this.opts.onExit();
            }
            handleFinishUnsubscribing(output);
          }));
          try {
            yield this._call(processService, "start", [
              processID,
              cmd,
              envVars,
              cwd
            ]);
          } catch (err) {
            triggerExit();
            yield unsubscribing;
            if (/error starting process '\w+': fork\/exec \/bin\/bash: no such file or directory/.test(err == null ? void 0 : err.message)) {
              throw new CurrentWorkingDirectoryDoesntExistError(
                `Failed to start the process. You are trying set 'cwd' to a directory that does not exist.
${err == null ? void 0 : err.message}`
              );
            }
            throw err;
          }
          return new Process(
            processID,
            this,
            triggerExit,
            unsubscribing,
            output
          );
        });
        const timeout = opts2.timeout;
        return yield withTimeout(start, timeout)(opts2);
      }),
      startAndWait: (optsOrCmd) => __async(this, null, function* () {
        const opts2 = typeof optsOrCmd === "string" ? { cmd: optsOrCmd } : optsOrCmd;
        const process2 = yield this.process.start(opts2);
        return yield process2.wait();
      })
    };
    const _resolvePath = (path2) => resolvePath(path2, this.cwd, this.logger);
  }
  /**
   * URL that can be used to download or upload file to the sandbox via a multipart/form-data POST request.
   * This is useful if you're uploading files directly from the browser.
   * The file will be uploaded to the user's home directory with the same name.
   * If a file with the same name already exists, it will be overwritten.
   */
  get fileURL() {
    const protocol = this.opts.__debug_devEnv === "local" ? "http" : "https";
    const hostname = this.getHostname(this.opts.__debug_port || ENVD_PORT);
    return `${protocol}://${hostname}${FILE_ROUTE}`;
  }
  /**
   * Returns a map of added actions.
   *
   * @returns Map of added actions
   */
  get actions() {
    return new Map(this._actions);
  }
  /**
   * OpenAI integration that can be used to get output for the actions added in the sandbox.
   *
   * @returns OpenAI integration
   */
  get openai() {
    return {
      actions: new Actions(this)
    };
  }
  static create(optsOrTemplate) {
    return __async(this, null, function* () {
      const opts = typeof optsOrTemplate === "string" ? { template: optsOrTemplate } : optsOrTemplate;
      const sandbox = new Sandbox(opts);
      yield sandbox._open({ timeout: opts == null ? void 0 : opts.timeout });
      return sandbox;
    });
  }
  static reconnect(sandboxIDorOpts) {
    return __async(this, null, function* () {
      let sandboxID;
      let opts;
      if (typeof sandboxIDorOpts === "string") {
        sandboxID = sandboxIDorOpts;
        opts = {};
      } else {
        sandboxID = sandboxIDorOpts.sandboxID;
        opts = sandboxIDorOpts;
      }
      const instanceIDAndClientID = sandboxID.split("-");
      const instanceID = instanceIDAndClientID[0];
      const clientID = instanceIDAndClientID[1];
      opts.__sandbox = { instanceID, clientID, envID: "unknown" };
      const sandbox = new Sandbox(opts);
      yield sandbox._open({ timeout: opts == null ? void 0 : opts.timeout });
      return sandbox;
    });
  }
  addAction(actionOrName, action) {
    if (typeof actionOrName === "string") {
      if (!action)
        throw new Error("Action is required");
      this._actions.set(actionOrName, action);
      return this;
    } else if (typeof actionOrName === "function") {
      action = actionOrName;
      if (!action.name) {
        throw new Error("Action name is required");
      }
      this._actions.set(action.name, action);
    } else {
      throw new Error("Action or action name and action is required");
    }
    return this;
  }
  /**
   * Remove an action.
   * @param name Action name
   * @returns Sandbox
   *
   * @example
   * ```ts
   * const sandbox = await Sandbox.create()
   * sandbox.addAction('hello', (sandbox, args) => 'Hello World')
   * sandbox.removeAction('hello')
   * ```
   */
  removeAction(name) {
    this._actions.delete(name);
    return this;
  }
  /**
   * Uploads a file to the sandbox.
   * The file will be uploaded to the user's home directory with the same name.
   * If a file with the same name already exists, it will be overwritten.
   *
   * **You can use the {@link Sandbox.fileURL} property and upload file directly via POST multipart/form-data**
   *
   */
  uploadFile(file, filename) {
    return __async(this, null, function* () {
      const body = new FormData();
      const blob = file instanceof Blob ? file : new Blob([file], { type: "application/octet-stream" });
      body.append("file", blob, filename);
      const response = yield fetch(this.fileURL, {
        method: "POST",
        body
      });
      if (!response.ok) {
        const text = yield response.text();
        throw new Error(
          `Failed to upload file ${response.status} - ${response.statusText}: ${text}`
        );
      }
      return `/home/user/${filename}`;
    });
  }
  /**
   * Downloads a file from the sandbox.
   * @param remotePath Path to a file on the sandbox
   * @param format Format of the downloaded file
   * @returns File content
   *
   * @example
   * ```ts
   * const sandbox = await Sandbox.create()
   * const content = await sandbox.downloadFile('/home/user/file.txt')
   * ```
   */
  downloadFile(remotePath, format) {
    return __async(this, null, function* () {
      remotePath = encodeURIComponent(remotePath);
      const response = yield fetch(`${this.fileURL}?path=${remotePath}`);
      if (!response.ok) {
        const text = yield response.text();
        throw new Error(`Failed to download file '${remotePath}': ${text}`);
      }
      switch (format) {
        case "base64":
          return Buffer.from(yield response.arrayBuffer()).toString("base64");
        case "blob":
          return yield response.blob();
        case "buffer":
          return Buffer.from(yield response.arrayBuffer());
        case "arraybuffer":
          return yield response.arrayBuffer();
        case "text":
          return yield response.text();
        default:
          return yield response.arrayBuffer();
      }
    });
  }
  _open(opts) {
    return __async(this, null, function* () {
      yield __superGet(Sandbox.prototype, this, "_open").call(this, opts);
      const portsHandler = this.onScanPorts ? (ports) => {
        var _a3;
        return (_a3 = this.onScanPorts) == null ? void 0 : _a3.call(
          this,
          ports.map((p) => ({ ip: p.Ip, port: p.Port, state: p.State }))
        );
      } : void 0;
      yield this._handleSubscriptions(
        portsHandler ? this._subscribe(codeSnippetService, portsHandler, "scanOpenedPorts") : void 0
      );
      if (this.cwd) {
        console.log(`Custom cwd for Sandbox set: "${this.cwd}"`);
        yield this.filesystem.makeDir(this.cwd);
      }
      this.handleStartCmdLogs();
      return this;
    });
  }
  handleStartCmdLogs() {
    return __async(this, null, function* () {
      this._startCmd = this.process.start({
        cmd: "sudo journalctl --follow --lines=all -o cat _SYSTEMD_UNIT=start_cmd.service",
        envVars: {},
        cwd: "/"
      });
    });
  }
};
var CodeRuntime = ((CodeRuntime2) => {
  CodeRuntime2["Node16"] = "Node16";
  CodeRuntime2["Python3"] = "Python3";
  CodeRuntime2["Bash"] = "Bash";
  CodeRuntime2["Python3_DataAnalysis"] = "Python3-DataAnalysis";
  return CodeRuntime2;
})(CodeRuntime || {});
function runCode(runtime, code, opts) {
  return __async(this, null, function* () {
    var _a3;
    let binary = "";
    let filepath = "";
    let envID = "";
    switch (runtime) {
      case "Node16":
        envID = "base";
        binary = "node";
        filepath = "/index.js";
        break;
      case "Python3":
        envID = "base";
        binary = "python3";
        filepath = "/main.py";
        break;
      case "Python3-DataAnalysis":
        envID = "Python3-DataAnalysis";
        binary = "python3";
        filepath = "/main.py";
        break;
      case "Bash":
        envID = "base";
        binary = "bash";
        filepath = "/main.sh";
        break;
      default:
        throw new Error(
          `The "${runtime}" runtime isn't supported. Please contact us (hello@e2b.dev) if you need support for this runtime`
        );
    }
    const sandbox = yield Sandbox.create({
      template: envID,
      apiKey: (opts == null ? void 0 : opts.apiKey) || ((_a3 = process == null ? void 0 : process.env) == null ? void 0 : _a3.E2B_API_KEY) || ""
      // Sandbox.create will throw an error if the API key is not provided so no need to check here
    });
    yield sandbox.filesystem.write(filepath, code);
    const codeProc = yield sandbox.process.start({
      cmd: `${binary} ${filepath}`
    });
    const out = yield codeProc.wait();
    yield sandbox.close();
    return {
      stdout: out.stdout,
      stderr: out.stderr
    };
  });
}
var Artifact = class {
  constructor(path2, sandbox) {
    this.path = path2;
    this._sandbox = sandbox;
  }
  download(format) {
    return __async(this, null, function* () {
      return this._sandbox.downloadFile(this.path, format);
    });
  }
};
var _DataAnalysis = class extends Sandbox {
  constructor(opts) {
    super(__spreadValues({ template: _DataAnalysis.template }, opts));
  }
  static create(opts) {
    return __async(this, null, function* () {
      const sandbox = new _DataAnalysis(__spreadValues({}, opts));
      yield sandbox._open({ timeout: opts == null ? void 0 : opts.timeout });
      return sandbox;
    });
  }
  runPython(_0) {
    return __async(this, arguments, function* (code, opts = {}) {
      const artifacts = [];
      const registerArtifacts = (event) => __async(this, null, function* () {
        var _a3;
        if (event.operation === "Create") {
          const artifact = new Artifact(event.path, this);
          artifacts.push(event.path);
          yield (_a3 = opts.onArtifact) == null ? void 0 : _a3.call(opts, artifact);
        }
      });
      const watcher = this.filesystem.watchDir("/home/user/artifacts");
      watcher.addEventListener(registerArtifacts);
      yield watcher.start();
      const currentEpoch = (/* @__PURE__ */ new Date()).getTime();
      const codefilePath = `/tmp/main-${currentEpoch}.py`;
      yield this.filesystem.write(codefilePath, code);
      const proc = yield this.process.start(__spreadValues({
        cmd: `python ${codefilePath}`
      }, opts));
      yield proc.wait();
      yield watcher.stop();
      return {
        stdout: proc.output.stdout,
        stderr: proc.output.stderr,
        artifacts: artifacts.map((artifact) => new Artifact(artifact, this))
      };
    });
  }
  installPythonPackages(packageNames) {
    return __async(this, null, function* () {
      yield this.installPackages("pip install", packageNames);
    });
  }
  installSystemPackages(packageNames) {
    return __async(this, null, function* () {
      yield this.installPackages("sudo apt-get install -y", packageNames);
    });
  }
  installPackages(command, packageNames) {
    return __async(this, null, function* () {
      if (Array.isArray(packageNames)) {
        packageNames = packageNames.join(" ");
      }
      packageNames = packageNames.trim();
      if (packageNames.length === 0) {
        return;
      }
      const proc = yield this.process.start({
        cmd: `${command} ${packageNames}`
      });
      yield proc.wait();
      if (proc.output.exitCode !== 0) {
        throw new Error(`Failed to install package ${packageNames}: ${proc.output.stderr}`);
      }
    });
  }
};
var DataAnalysis = _DataAnalysis;
DataAnalysis.template = "Python3-DataAnalysis";
var src_default = Sandbox;
export {
  API_HOST,
  Artifact,
  DataAnalysis as CodeInterpreter,
  CodeRuntime,
  DataAnalysis,
  FilesystemOperation,
  filesystemWatcher_default as FilesystemWatcher,
  Process,
  ProcessMessage,
  ProcessOutput,
  SANDBOX_DOMAIN,
  Sandbox,
  Terminal,
  TerminalOutput,
  api_default as api,
  src_default as default,
  runCode,
  withAPIKey,
  withAccessToken
};
/*! Bundled license information:

platform/platform.js:
  (*!
   * Platform.js v1.3.6
   * Copyright 2014-2020 Benjamin Tan
   * Copyright 2011-2013 John-David Dalton
   * Available under MIT license
   *)

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=@e2b_sdk.js.map
